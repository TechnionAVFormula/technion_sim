// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2eproto;
namespace TechnionFormulaAV {
namespace Messages {
class ConnectionApproved;
class ConnectionApprovedDefaultTypeInternal;
extern ConnectionApprovedDefaultTypeInternal _ConnectionApproved_default_instance_;
class ExitMessage;
class ExitMessageDefaultTypeInternal;
extern ExitMessageDefaultTypeInternal _ExitMessage_default_instance_;
class FinishedControlLap;
class FinishedControlLapDefaultTypeInternal;
extern FinishedControlLapDefaultTypeInternal _FinishedControlLap_default_instance_;
class FinishedFinalLap;
class FinishedFinalLapDefaultTypeInternal;
extern FinishedFinalLapDefaultTypeInternal _FinishedFinalLap_default_instance_;
class SwitchToASDReady;
class SwitchToASDReadyDefaultTypeInternal;
extern SwitchToASDReadyDefaultTypeInternal _SwitchToASDReady_default_instance_;
class SwitchToASDriving;
class SwitchToASDrivingDefaultTypeInternal;
extern SwitchToASDrivingDefaultTypeInternal _SwitchToASDriving_default_instance_;
class SwitchToASEmergency;
class SwitchToASEmergencyDefaultTypeInternal;
extern SwitchToASEmergencyDefaultTypeInternal _SwitchToASEmergency_default_instance_;
class SwitchToASFinished;
class SwitchToASFinishedDefaultTypeInternal;
extern SwitchToASFinishedDefaultTypeInternal _SwitchToASFinished_default_instance_;
class SwitchToASOff;
class SwitchToASOffDefaultTypeInternal;
extern SwitchToASOffDefaultTypeInternal _SwitchToASOff_default_instance_;
}  // namespace Messages
}  // namespace TechnionFormulaAV
PROTOBUF_NAMESPACE_OPEN
template<> ::TechnionFormulaAV::Messages::ConnectionApproved* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::ConnectionApproved>(Arena*);
template<> ::TechnionFormulaAV::Messages::ExitMessage* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::ExitMessage>(Arena*);
template<> ::TechnionFormulaAV::Messages::FinishedControlLap* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::FinishedControlLap>(Arena*);
template<> ::TechnionFormulaAV::Messages::FinishedFinalLap* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::FinishedFinalLap>(Arena*);
template<> ::TechnionFormulaAV::Messages::SwitchToASDReady* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::SwitchToASDReady>(Arena*);
template<> ::TechnionFormulaAV::Messages::SwitchToASDriving* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::SwitchToASDriving>(Arena*);
template<> ::TechnionFormulaAV::Messages::SwitchToASEmergency* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::SwitchToASEmergency>(Arena*);
template<> ::TechnionFormulaAV::Messages::SwitchToASFinished* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::SwitchToASFinished>(Arena*);
template<> ::TechnionFormulaAV::Messages::SwitchToASOff* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::SwitchToASOff>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TechnionFormulaAV {
namespace Messages {

// ===================================================================

class ExitMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.ExitMessage) */ {
 public:
  ExitMessage();
  virtual ~ExitMessage();

  ExitMessage(const ExitMessage& from);
  ExitMessage(ExitMessage&& from) noexcept
    : ExitMessage() {
    *this = ::std::move(from);
  }

  inline ExitMessage& operator=(const ExitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitMessage& operator=(ExitMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExitMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExitMessage* internal_default_instance() {
    return reinterpret_cast<const ExitMessage*>(
               &_ExitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ExitMessage* other);
  friend void swap(ExitMessage& a, ExitMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExitMessage* New() const final {
    return CreateMaybeMessage<ExitMessage>(nullptr);
  }

  ExitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExitMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExitMessage& from);
  void MergeFrom(const ExitMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExitMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.ExitMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.ExitMessage)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ConnectionApproved :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.ConnectionApproved) */ {
 public:
  ConnectionApproved();
  virtual ~ConnectionApproved();

  ConnectionApproved(const ConnectionApproved& from);
  ConnectionApproved(ConnectionApproved&& from) noexcept
    : ConnectionApproved() {
    *this = ::std::move(from);
  }

  inline ConnectionApproved& operator=(const ConnectionApproved& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionApproved& operator=(ConnectionApproved&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectionApproved& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionApproved* internal_default_instance() {
    return reinterpret_cast<const ConnectionApproved*>(
               &_ConnectionApproved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ConnectionApproved* other);
  friend void swap(ConnectionApproved& a, ConnectionApproved& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionApproved* New() const final {
    return CreateMaybeMessage<ConnectionApproved>(nullptr);
  }

  ConnectionApproved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionApproved>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectionApproved& from);
  void MergeFrom(const ConnectionApproved& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionApproved* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.ConnectionApproved";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.ConnectionApproved)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class SwitchToASOff :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.SwitchToASOff) */ {
 public:
  SwitchToASOff();
  virtual ~SwitchToASOff();

  SwitchToASOff(const SwitchToASOff& from);
  SwitchToASOff(SwitchToASOff&& from) noexcept
    : SwitchToASOff() {
    *this = ::std::move(from);
  }

  inline SwitchToASOff& operator=(const SwitchToASOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchToASOff& operator=(SwitchToASOff&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwitchToASOff& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchToASOff* internal_default_instance() {
    return reinterpret_cast<const SwitchToASOff*>(
               &_SwitchToASOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SwitchToASOff* other);
  friend void swap(SwitchToASOff& a, SwitchToASOff& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchToASOff* New() const final {
    return CreateMaybeMessage<SwitchToASOff>(nullptr);
  }

  SwitchToASOff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwitchToASOff>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwitchToASOff& from);
  void MergeFrom(const SwitchToASOff& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchToASOff* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.SwitchToASOff";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.SwitchToASOff)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class SwitchToASDReady :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.SwitchToASDReady) */ {
 public:
  SwitchToASDReady();
  virtual ~SwitchToASDReady();

  SwitchToASDReady(const SwitchToASDReady& from);
  SwitchToASDReady(SwitchToASDReady&& from) noexcept
    : SwitchToASDReady() {
    *this = ::std::move(from);
  }

  inline SwitchToASDReady& operator=(const SwitchToASDReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchToASDReady& operator=(SwitchToASDReady&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwitchToASDReady& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchToASDReady* internal_default_instance() {
    return reinterpret_cast<const SwitchToASDReady*>(
               &_SwitchToASDReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SwitchToASDReady* other);
  friend void swap(SwitchToASDReady& a, SwitchToASDReady& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchToASDReady* New() const final {
    return CreateMaybeMessage<SwitchToASDReady>(nullptr);
  }

  SwitchToASDReady* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwitchToASDReady>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwitchToASDReady& from);
  void MergeFrom(const SwitchToASDReady& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchToASDReady* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.SwitchToASDReady";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.Mission mission = 1;
  void clear_mission();
  static const int kMissionFieldNumber = 1;
  ::TechnionFormulaAV::Messages::Mission mission() const;
  void set_mission(::TechnionFormulaAV::Messages::Mission value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.SwitchToASDReady)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int mission_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class SwitchToASDriving :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.SwitchToASDriving) */ {
 public:
  SwitchToASDriving();
  virtual ~SwitchToASDriving();

  SwitchToASDriving(const SwitchToASDriving& from);
  SwitchToASDriving(SwitchToASDriving&& from) noexcept
    : SwitchToASDriving() {
    *this = ::std::move(from);
  }

  inline SwitchToASDriving& operator=(const SwitchToASDriving& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchToASDriving& operator=(SwitchToASDriving&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwitchToASDriving& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchToASDriving* internal_default_instance() {
    return reinterpret_cast<const SwitchToASDriving*>(
               &_SwitchToASDriving_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SwitchToASDriving* other);
  friend void swap(SwitchToASDriving& a, SwitchToASDriving& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchToASDriving* New() const final {
    return CreateMaybeMessage<SwitchToASDriving>(nullptr);
  }

  SwitchToASDriving* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwitchToASDriving>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwitchToASDriving& from);
  void MergeFrom(const SwitchToASDriving& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchToASDriving* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.SwitchToASDriving";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.SwitchToASDriving)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class SwitchToASFinished :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.SwitchToASFinished) */ {
 public:
  SwitchToASFinished();
  virtual ~SwitchToASFinished();

  SwitchToASFinished(const SwitchToASFinished& from);
  SwitchToASFinished(SwitchToASFinished&& from) noexcept
    : SwitchToASFinished() {
    *this = ::std::move(from);
  }

  inline SwitchToASFinished& operator=(const SwitchToASFinished& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchToASFinished& operator=(SwitchToASFinished&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwitchToASFinished& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchToASFinished* internal_default_instance() {
    return reinterpret_cast<const SwitchToASFinished*>(
               &_SwitchToASFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SwitchToASFinished* other);
  friend void swap(SwitchToASFinished& a, SwitchToASFinished& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchToASFinished* New() const final {
    return CreateMaybeMessage<SwitchToASFinished>(nullptr);
  }

  SwitchToASFinished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwitchToASFinished>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwitchToASFinished& from);
  void MergeFrom(const SwitchToASFinished& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchToASFinished* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.SwitchToASFinished";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.SwitchToASFinished)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class SwitchToASEmergency :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.SwitchToASEmergency) */ {
 public:
  SwitchToASEmergency();
  virtual ~SwitchToASEmergency();

  SwitchToASEmergency(const SwitchToASEmergency& from);
  SwitchToASEmergency(SwitchToASEmergency&& from) noexcept
    : SwitchToASEmergency() {
    *this = ::std::move(from);
  }

  inline SwitchToASEmergency& operator=(const SwitchToASEmergency& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchToASEmergency& operator=(SwitchToASEmergency&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwitchToASEmergency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchToASEmergency* internal_default_instance() {
    return reinterpret_cast<const SwitchToASEmergency*>(
               &_SwitchToASEmergency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SwitchToASEmergency* other);
  friend void swap(SwitchToASEmergency& a, SwitchToASEmergency& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchToASEmergency* New() const final {
    return CreateMaybeMessage<SwitchToASEmergency>(nullptr);
  }

  SwitchToASEmergency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwitchToASEmergency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwitchToASEmergency& from);
  void MergeFrom(const SwitchToASEmergency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchToASEmergency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.SwitchToASEmergency";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.SwitchToASEmergency)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class FinishedControlLap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.FinishedControlLap) */ {
 public:
  FinishedControlLap();
  virtual ~FinishedControlLap();

  FinishedControlLap(const FinishedControlLap& from);
  FinishedControlLap(FinishedControlLap&& from) noexcept
    : FinishedControlLap() {
    *this = ::std::move(from);
  }

  inline FinishedControlLap& operator=(const FinishedControlLap& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishedControlLap& operator=(FinishedControlLap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FinishedControlLap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinishedControlLap* internal_default_instance() {
    return reinterpret_cast<const FinishedControlLap*>(
               &_FinishedControlLap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(FinishedControlLap* other);
  friend void swap(FinishedControlLap& a, FinishedControlLap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinishedControlLap* New() const final {
    return CreateMaybeMessage<FinishedControlLap>(nullptr);
  }

  FinishedControlLap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FinishedControlLap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FinishedControlLap& from);
  void MergeFrom(const FinishedControlLap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishedControlLap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.FinishedControlLap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.FinishedControlLap)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class FinishedFinalLap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.FinishedFinalLap) */ {
 public:
  FinishedFinalLap();
  virtual ~FinishedFinalLap();

  FinishedFinalLap(const FinishedFinalLap& from);
  FinishedFinalLap(FinishedFinalLap&& from) noexcept
    : FinishedFinalLap() {
    *this = ::std::move(from);
  }

  inline FinishedFinalLap& operator=(const FinishedFinalLap& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishedFinalLap& operator=(FinishedFinalLap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FinishedFinalLap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinishedFinalLap* internal_default_instance() {
    return reinterpret_cast<const FinishedFinalLap*>(
               &_FinishedFinalLap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(FinishedFinalLap* other);
  friend void swap(FinishedFinalLap& a, FinishedFinalLap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinishedFinalLap* New() const final {
    return CreateMaybeMessage<FinishedFinalLap>(nullptr);
  }

  FinishedFinalLap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FinishedFinalLap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FinishedFinalLap& from);
  void MergeFrom(const FinishedFinalLap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishedFinalLap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.FinishedFinalLap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_server_2eproto);
    return ::descriptor_table_server_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.FinishedFinalLap)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExitMessage

// -------------------------------------------------------------------

// ConnectionApproved

// -------------------------------------------------------------------

// SwitchToASOff

// -------------------------------------------------------------------

// SwitchToASDReady

// .TechnionFormulaAV.Messages.Mission mission = 1;
inline void SwitchToASDReady::clear_mission() {
  mission_ = 0;
}
inline ::TechnionFormulaAV::Messages::Mission SwitchToASDReady::mission() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.SwitchToASDReady.mission)
  return static_cast< ::TechnionFormulaAV::Messages::Mission >(mission_);
}
inline void SwitchToASDReady::set_mission(::TechnionFormulaAV::Messages::Mission value) {
  
  mission_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.SwitchToASDReady.mission)
}

// -------------------------------------------------------------------

// SwitchToASDriving

// -------------------------------------------------------------------

// SwitchToASFinished

// -------------------------------------------------------------------

// SwitchToASEmergency

// -------------------------------------------------------------------

// FinishedControlLap

// -------------------------------------------------------------------

// FinishedFinalLap

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Messages
}  // namespace TechnionFormulaAV

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
