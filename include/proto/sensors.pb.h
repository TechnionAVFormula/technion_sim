// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensors_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sensors_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sensors_2eproto;
namespace TechnionFormulaAV {
namespace Messages {
class ActualDriveInstructions;
class ActualDriveInstructionsDefaultTypeInternal;
extern ActualDriveInstructionsDefaultTypeInternal _ActualDriveInstructions_default_instance_;
class CameraConfig;
class CameraConfigDefaultTypeInternal;
extern CameraConfigDefaultTypeInternal _CameraConfig_default_instance_;
class CameraSensor;
class CameraSensorDefaultTypeInternal;
extern CameraSensorDefaultTypeInternal _CameraSensor_default_instance_;
class Can;
class CanDefaultTypeInternal;
extern CanDefaultTypeInternal _Can_default_instance_;
class CarData;
class CarDataDefaultTypeInternal;
extern CarDataDefaultTypeInternal _CarData_default_instance_;
class CarMeasurments;
class CarMeasurmentsDefaultTypeInternal;
extern CarMeasurmentsDefaultTypeInternal _CarMeasurments_default_instance_;
class DepthCameraConfig;
class DepthCameraConfigDefaultTypeInternal;
extern DepthCameraConfigDefaultTypeInternal _DepthCameraConfig_default_instance_;
class DepthCameraSensor;
class DepthCameraSensorDefaultTypeInternal;
extern DepthCameraSensorDefaultTypeInternal _DepthCameraSensor_default_instance_;
class GPSConfig;
class GPSConfigDefaultTypeInternal;
extern GPSConfigDefaultTypeInternal _GPSConfig_default_instance_;
class GPSSensor;
class GPSSensorDefaultTypeInternal;
extern GPSSensorDefaultTypeInternal _GPSSensor_default_instance_;
class IMUConfig;
class IMUConfigDefaultTypeInternal;
extern IMUConfigDefaultTypeInternal _IMUConfig_default_instance_;
class IMUMeasurments;
class IMUMeasurmentsDefaultTypeInternal;
extern IMUMeasurmentsDefaultTypeInternal _IMUMeasurments_default_instance_;
class IMUSensor;
class IMUSensorDefaultTypeInternal;
extern IMUSensorDefaultTypeInternal _IMUSensor_default_instance_;
class LidarConfig;
class LidarConfigDefaultTypeInternal;
extern LidarConfigDefaultTypeInternal _LidarConfig_default_instance_;
class LidarSensor;
class LidarSensorDefaultTypeInternal;
extern LidarSensorDefaultTypeInternal _LidarSensor_default_instance_;
}  // namespace Messages
}  // namespace TechnionFormulaAV
PROTOBUF_NAMESPACE_OPEN
template<> ::TechnionFormulaAV::Messages::ActualDriveInstructions* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::ActualDriveInstructions>(Arena*);
template<> ::TechnionFormulaAV::Messages::CameraConfig* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::CameraConfig>(Arena*);
template<> ::TechnionFormulaAV::Messages::CameraSensor* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::CameraSensor>(Arena*);
template<> ::TechnionFormulaAV::Messages::Can* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::Can>(Arena*);
template<> ::TechnionFormulaAV::Messages::CarData* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::CarData>(Arena*);
template<> ::TechnionFormulaAV::Messages::CarMeasurments* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::CarMeasurments>(Arena*);
template<> ::TechnionFormulaAV::Messages::DepthCameraConfig* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::DepthCameraConfig>(Arena*);
template<> ::TechnionFormulaAV::Messages::DepthCameraSensor* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::DepthCameraSensor>(Arena*);
template<> ::TechnionFormulaAV::Messages::GPSConfig* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::GPSConfig>(Arena*);
template<> ::TechnionFormulaAV::Messages::GPSSensor* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::GPSSensor>(Arena*);
template<> ::TechnionFormulaAV::Messages::IMUConfig* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::IMUConfig>(Arena*);
template<> ::TechnionFormulaAV::Messages::IMUMeasurments* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::IMUMeasurments>(Arena*);
template<> ::TechnionFormulaAV::Messages::IMUSensor* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::IMUSensor>(Arena*);
template<> ::TechnionFormulaAV::Messages::LidarConfig* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::LidarConfig>(Arena*);
template<> ::TechnionFormulaAV::Messages::LidarSensor* Arena::CreateMaybeMessage<::TechnionFormulaAV::Messages::LidarSensor>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TechnionFormulaAV {
namespace Messages {

enum DepthCameraDataType : int {
  DCH_Float32 = 0,
  DCS_UInt16 = 1,
  DepthCameraDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DepthCameraDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DepthCameraDataType_IsValid(int value);
constexpr DepthCameraDataType DepthCameraDataType_MIN = DCH_Float32;
constexpr DepthCameraDataType DepthCameraDataType_MAX = DCS_UInt16;
constexpr int DepthCameraDataType_ARRAYSIZE = DepthCameraDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DepthCameraDataType_descriptor();
template<typename T>
inline const std::string& DepthCameraDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DepthCameraDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DepthCameraDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DepthCameraDataType_descriptor(), enum_t_value);
}
inline bool DepthCameraDataType_Parse(
    const std::string& name, DepthCameraDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DepthCameraDataType>(
    DepthCameraDataType_descriptor(), name, value);
}
// ===================================================================

class IMUConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.IMUConfig) */ {
 public:
  IMUConfig();
  virtual ~IMUConfig();

  IMUConfig(const IMUConfig& from);
  IMUConfig(IMUConfig&& from) noexcept
    : IMUConfig() {
    *this = ::std::move(from);
  }

  inline IMUConfig& operator=(const IMUConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUConfig& operator=(IMUConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IMUConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMUConfig* internal_default_instance() {
    return reinterpret_cast<const IMUConfig*>(
               &_IMUConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(IMUConfig* other);
  friend void swap(IMUConfig& a, IMUConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMUConfig* New() const final {
    return CreateMaybeMessage<IMUConfig>(nullptr);
  }

  IMUConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMUConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IMUConfig& from);
  void MergeFrom(const IMUConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.IMUConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
  bool has_sensor_position() const;
  void clear_sensor_position();
  static const int kSensorPositionFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::Vector3D& sensor_position() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_sensor_position();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_sensor_position();
  void set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position);

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.IMUConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::Vector3D* sensor_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class GPSConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.GPSConfig) */ {
 public:
  GPSConfig();
  virtual ~GPSConfig();

  GPSConfig(const GPSConfig& from);
  GPSConfig(GPSConfig&& from) noexcept
    : GPSConfig() {
    *this = ::std::move(from);
  }

  inline GPSConfig& operator=(const GPSConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPSConfig& operator=(GPSConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GPSConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GPSConfig* internal_default_instance() {
    return reinterpret_cast<const GPSConfig*>(
               &_GPSConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GPSConfig* other);
  friend void swap(GPSConfig& a, GPSConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GPSConfig* New() const final {
    return CreateMaybeMessage<GPSConfig>(nullptr);
  }

  GPSConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GPSConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GPSConfig& from);
  void MergeFrom(const GPSConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPSConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.GPSConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
  bool has_sensor_position() const;
  void clear_sensor_position();
  static const int kSensorPositionFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::Vector3D& sensor_position() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_sensor_position();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_sensor_position();
  void set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position);

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.GPSConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::Vector3D* sensor_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class CameraConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.CameraConfig) */ {
 public:
  CameraConfig();
  virtual ~CameraConfig();

  CameraConfig(const CameraConfig& from);
  CameraConfig(CameraConfig&& from) noexcept
    : CameraConfig() {
    *this = ::std::move(from);
  }

  inline CameraConfig& operator=(const CameraConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraConfig& operator=(CameraConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraConfig* internal_default_instance() {
    return reinterpret_cast<const CameraConfig*>(
               &_CameraConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CameraConfig* other);
  friend void swap(CameraConfig& a, CameraConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraConfig* New() const final {
    return CreateMaybeMessage<CameraConfig>(nullptr);
  }

  CameraConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraConfig& from);
  void MergeFrom(const CameraConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.CameraConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
  bool has_sensor_position() const;
  void clear_sensor_position();
  static const int kSensorPositionFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::Vector3D& sensor_position() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_sensor_position();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_sensor_position();
  void set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position);

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // float hfov = 3;
  void clear_hfov();
  static const int kHfovFieldNumber = 3;
  float hfov() const;
  void set_hfov(float value);

  // float vfov = 4;
  void clear_vfov();
  static const int kVfovFieldNumber = 4;
  float vfov() const;
  void set_vfov(float value);

  // uint32 width = 5;
  void clear_width();
  static const int kWidthFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 height = 6;
  void clear_height();
  static const int kHeightFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.CameraConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::Vector3D* sensor_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  float hfov_;
  float vfov_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class LidarConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.LidarConfig) */ {
 public:
  LidarConfig();
  virtual ~LidarConfig();

  LidarConfig(const LidarConfig& from);
  LidarConfig(LidarConfig&& from) noexcept
    : LidarConfig() {
    *this = ::std::move(from);
  }

  inline LidarConfig& operator=(const LidarConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarConfig& operator=(LidarConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LidarConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarConfig* internal_default_instance() {
    return reinterpret_cast<const LidarConfig*>(
               &_LidarConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LidarConfig* other);
  friend void swap(LidarConfig& a, LidarConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarConfig* New() const final {
    return CreateMaybeMessage<LidarConfig>(nullptr);
  }

  LidarConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LidarConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LidarConfig& from);
  void MergeFrom(const LidarConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.LidarConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
  bool has_sensor_position() const;
  void clear_sensor_position();
  static const int kSensorPositionFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::Vector3D& sensor_position() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_sensor_position();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_sensor_position();
  void set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position);

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // float hfov = 3;
  void clear_hfov();
  static const int kHfovFieldNumber = 3;
  float hfov() const;
  void set_hfov(float value);

  // float vfov = 4;
  void clear_vfov();
  static const int kVfovFieldNumber = 4;
  float vfov() const;
  void set_vfov(float value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.LidarConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::Vector3D* sensor_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  float hfov_;
  float vfov_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class DepthCameraConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.DepthCameraConfig) */ {
 public:
  DepthCameraConfig();
  virtual ~DepthCameraConfig();

  DepthCameraConfig(const DepthCameraConfig& from);
  DepthCameraConfig(DepthCameraConfig&& from) noexcept
    : DepthCameraConfig() {
    *this = ::std::move(from);
  }

  inline DepthCameraConfig& operator=(const DepthCameraConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepthCameraConfig& operator=(DepthCameraConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DepthCameraConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthCameraConfig* internal_default_instance() {
    return reinterpret_cast<const DepthCameraConfig*>(
               &_DepthCameraConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DepthCameraConfig* other);
  friend void swap(DepthCameraConfig& a, DepthCameraConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthCameraConfig* New() const final {
    return CreateMaybeMessage<DepthCameraConfig>(nullptr);
  }

  DepthCameraConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DepthCameraConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DepthCameraConfig& from);
  void MergeFrom(const DepthCameraConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthCameraConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.DepthCameraConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
  bool has_sensor_position() const;
  void clear_sensor_position();
  static const int kSensorPositionFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::Vector3D& sensor_position() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_sensor_position();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_sensor_position();
  void set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position);

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // float hfov = 3;
  void clear_hfov();
  static const int kHfovFieldNumber = 3;
  float hfov() const;
  void set_hfov(float value);

  // float vfov = 4;
  void clear_vfov();
  static const int kVfovFieldNumber = 4;
  float vfov() const;
  void set_vfov(float value);

  // uint32 width = 5;
  void clear_width();
  static const int kWidthFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 height = 6;
  void clear_height();
  static const int kHeightFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .TechnionFormulaAV.Messages.DepthCameraDataType data_type = 7;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 7;
  ::TechnionFormulaAV::Messages::DepthCameraDataType data_type() const;
  void set_data_type(::TechnionFormulaAV::Messages::DepthCameraDataType value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.DepthCameraConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::Vector3D* sensor_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  float hfov_;
  float vfov_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  int data_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class CarMeasurments :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.CarMeasurments) */ {
 public:
  CarMeasurments();
  virtual ~CarMeasurments();

  CarMeasurments(const CarMeasurments& from);
  CarMeasurments(CarMeasurments&& from) noexcept
    : CarMeasurments() {
    *this = ::std::move(from);
  }

  inline CarMeasurments& operator=(const CarMeasurments& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarMeasurments& operator=(CarMeasurments&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarMeasurments& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarMeasurments* internal_default_instance() {
    return reinterpret_cast<const CarMeasurments*>(
               &_CarMeasurments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CarMeasurments* other);
  friend void swap(CarMeasurments& a, CarMeasurments& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CarMeasurments* New() const final {
    return CreateMaybeMessage<CarMeasurments>(nullptr);
  }

  CarMeasurments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarMeasurments>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarMeasurments& from);
  void MergeFrom(const CarMeasurments& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarMeasurments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.CarMeasurments";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double wheel_velocity_rear_left = 1;
  void clear_wheel_velocity_rear_left();
  static const int kWheelVelocityRearLeftFieldNumber = 1;
  double wheel_velocity_rear_left() const;
  void set_wheel_velocity_rear_left(double value);

  // double wheel_velocity_rear_right = 2;
  void clear_wheel_velocity_rear_right();
  static const int kWheelVelocityRearRightFieldNumber = 2;
  double wheel_velocity_rear_right() const;
  void set_wheel_velocity_rear_right(double value);

  // double wheel_velocity_front_left = 3;
  void clear_wheel_velocity_front_left();
  static const int kWheelVelocityFrontLeftFieldNumber = 3;
  double wheel_velocity_front_left() const;
  void set_wheel_velocity_front_left(double value);

  // double wheel_velocity_front_right = 4;
  void clear_wheel_velocity_front_right();
  static const int kWheelVelocityFrontRightFieldNumber = 4;
  double wheel_velocity_front_right() const;
  void set_wheel_velocity_front_right(double value);

  // double throttle_position = 5;
  void clear_throttle_position();
  static const int kThrottlePositionFieldNumber = 5;
  double throttle_position() const;
  void set_throttle_position(double value);

  // double steering_angle = 6;
  void clear_steering_angle();
  static const int kSteeringAngleFieldNumber = 6;
  double steering_angle() const;
  void set_steering_angle(double value);

  // double brakes_position = 7;
  void clear_brakes_position();
  static const int kBrakesPositionFieldNumber = 7;
  double brakes_position() const;
  void set_brakes_position(double value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.CarMeasurments)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double wheel_velocity_rear_left_;
  double wheel_velocity_rear_right_;
  double wheel_velocity_front_left_;
  double wheel_velocity_front_right_;
  double throttle_position_;
  double steering_angle_;
  double brakes_position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class IMUMeasurments :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.IMUMeasurments) */ {
 public:
  IMUMeasurments();
  virtual ~IMUMeasurments();

  IMUMeasurments(const IMUMeasurments& from);
  IMUMeasurments(IMUMeasurments&& from) noexcept
    : IMUMeasurments() {
    *this = ::std::move(from);
  }

  inline IMUMeasurments& operator=(const IMUMeasurments& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUMeasurments& operator=(IMUMeasurments&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IMUMeasurments& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMUMeasurments* internal_default_instance() {
    return reinterpret_cast<const IMUMeasurments*>(
               &_IMUMeasurments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(IMUMeasurments* other);
  friend void swap(IMUMeasurments& a, IMUMeasurments& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMUMeasurments* New() const final {
    return CreateMaybeMessage<IMUMeasurments>(nullptr);
  }

  IMUMeasurments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMUMeasurments>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IMUMeasurments& from);
  void MergeFrom(const IMUMeasurments& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUMeasurments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.IMUMeasurments";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.Vector3D acceleration = 2;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::Vector3D& acceleration() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_acceleration();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_acceleration();
  void set_allocated_acceleration(::TechnionFormulaAV::Messages::Vector3D* acceleration);

  // .TechnionFormulaAV.Messages.Vector3D angular_acceleration = 3;
  bool has_angular_acceleration() const;
  void clear_angular_acceleration();
  static const int kAngularAccelerationFieldNumber = 3;
  const ::TechnionFormulaAV::Messages::Vector3D& angular_acceleration() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_angular_acceleration();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_angular_acceleration();
  void set_allocated_angular_acceleration(::TechnionFormulaAV::Messages::Vector3D* angular_acceleration);

  // .TechnionFormulaAV.Messages.Vector3D velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  const ::TechnionFormulaAV::Messages::Vector3D& velocity() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_velocity();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_velocity();
  void set_allocated_velocity(::TechnionFormulaAV::Messages::Vector3D* velocity);

  // .TechnionFormulaAV.Messages.Vector3D angular_velocity = 5;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 5;
  const ::TechnionFormulaAV::Messages::Vector3D& angular_velocity() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_angular_velocity();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_angular_velocity();
  void set_allocated_angular_velocity(::TechnionFormulaAV::Messages::Vector3D* angular_velocity);

  // .TechnionFormulaAV.Messages.Vector3D orientation = 6;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 6;
  const ::TechnionFormulaAV::Messages::Vector3D& orientation() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_orientation();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_orientation();
  void set_allocated_orientation(::TechnionFormulaAV::Messages::Vector3D* orientation);

  // double heading = 7;
  void clear_heading();
  static const int kHeadingFieldNumber = 7;
  double heading() const;
  void set_heading(double value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.IMUMeasurments)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::Vector3D* acceleration_;
  ::TechnionFormulaAV::Messages::Vector3D* angular_acceleration_;
  ::TechnionFormulaAV::Messages::Vector3D* velocity_;
  ::TechnionFormulaAV::Messages::Vector3D* angular_velocity_;
  ::TechnionFormulaAV::Messages::Vector3D* orientation_;
  double heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class IMUSensor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.IMUSensor) */ {
 public:
  IMUSensor();
  virtual ~IMUSensor();

  IMUSensor(const IMUSensor& from);
  IMUSensor(IMUSensor&& from) noexcept
    : IMUSensor() {
    *this = ::std::move(from);
  }

  inline IMUSensor& operator=(const IMUSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUSensor& operator=(IMUSensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IMUSensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMUSensor* internal_default_instance() {
    return reinterpret_cast<const IMUSensor*>(
               &_IMUSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(IMUSensor* other);
  friend void swap(IMUSensor& a, IMUSensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMUSensor* New() const final {
    return CreateMaybeMessage<IMUSensor>(nullptr);
  }

  IMUSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMUSensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IMUSensor& from);
  void MergeFrom(const IMUSensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUSensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.IMUSensor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.IMUConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::TechnionFormulaAV::Messages::IMUConfig& config() const;
  ::TechnionFormulaAV::Messages::IMUConfig* release_config();
  ::TechnionFormulaAV::Messages::IMUConfig* mutable_config();
  void set_allocated_config(::TechnionFormulaAV::Messages::IMUConfig* config);

  // .TechnionFormulaAV.Messages.IMUMeasurments imu_measurments = 2;
  bool has_imu_measurments() const;
  void clear_imu_measurments();
  static const int kImuMeasurmentsFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::IMUMeasurments& imu_measurments() const;
  ::TechnionFormulaAV::Messages::IMUMeasurments* release_imu_measurments();
  ::TechnionFormulaAV::Messages::IMUMeasurments* mutable_imu_measurments();
  void set_allocated_imu_measurments(::TechnionFormulaAV::Messages::IMUMeasurments* imu_measurments);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.IMUSensor)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::IMUConfig* config_;
  ::TechnionFormulaAV::Messages::IMUMeasurments* imu_measurments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class CarData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.CarData) */ {
 public:
  CarData();
  virtual ~CarData();

  CarData(const CarData& from);
  CarData(CarData&& from) noexcept
    : CarData() {
    *this = ::std::move(from);
  }

  inline CarData& operator=(const CarData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarData& operator=(CarData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarData* internal_default_instance() {
    return reinterpret_cast<const CarData*>(
               &_CarData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CarData* other);
  friend void swap(CarData& a, CarData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CarData* New() const final {
    return CreateMaybeMessage<CarData>(nullptr);
  }

  CarData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarData& from);
  void MergeFrom(const CarData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.CarData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.IMUSensor imu_sensor = 1;
  bool has_imu_sensor() const;
  void clear_imu_sensor();
  static const int kImuSensorFieldNumber = 1;
  const ::TechnionFormulaAV::Messages::IMUSensor& imu_sensor() const;
  ::TechnionFormulaAV::Messages::IMUSensor* release_imu_sensor();
  ::TechnionFormulaAV::Messages::IMUSensor* mutable_imu_sensor();
  void set_allocated_imu_sensor(::TechnionFormulaAV::Messages::IMUSensor* imu_sensor);

  // .TechnionFormulaAV.Messages.CarMeasurments car_measurments = 2;
  bool has_car_measurments() const;
  void clear_car_measurments();
  static const int kCarMeasurmentsFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::CarMeasurments& car_measurments() const;
  ::TechnionFormulaAV::Messages::CarMeasurments* release_car_measurments();
  ::TechnionFormulaAV::Messages::CarMeasurments* mutable_car_measurments();
  void set_allocated_car_measurments(::TechnionFormulaAV::Messages::CarMeasurments* car_measurments);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.CarData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::IMUSensor* imu_sensor_;
  ::TechnionFormulaAV::Messages::CarMeasurments* car_measurments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class GPSSensor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.GPSSensor) */ {
 public:
  GPSSensor();
  virtual ~GPSSensor();

  GPSSensor(const GPSSensor& from);
  GPSSensor(GPSSensor&& from) noexcept
    : GPSSensor() {
    *this = ::std::move(from);
  }

  inline GPSSensor& operator=(const GPSSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPSSensor& operator=(GPSSensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GPSSensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GPSSensor* internal_default_instance() {
    return reinterpret_cast<const GPSSensor*>(
               &_GPSSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GPSSensor* other);
  friend void swap(GPSSensor& a, GPSSensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GPSSensor* New() const final {
    return CreateMaybeMessage<GPSSensor>(nullptr);
  }

  GPSSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GPSSensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GPSSensor& from);
  void MergeFrom(const GPSSensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPSSensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.GPSSensor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TechnionFormulaAV.Messages.GPSConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::TechnionFormulaAV::Messages::GPSConfig& config() const;
  ::TechnionFormulaAV::Messages::GPSConfig* release_config();
  ::TechnionFormulaAV::Messages::GPSConfig* mutable_config();
  void set_allocated_config(::TechnionFormulaAV::Messages::GPSConfig* config);

  // .TechnionFormulaAV.Messages.Vector3D position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::TechnionFormulaAV::Messages::Vector3D& position() const;
  ::TechnionFormulaAV::Messages::Vector3D* release_position();
  ::TechnionFormulaAV::Messages::Vector3D* mutable_position();
  void set_allocated_position(::TechnionFormulaAV::Messages::Vector3D* position);

  // double latitude = 4;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // double longitude = 5;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // double course = 6;
  void clear_course();
  static const int kCourseFieldNumber = 6;
  double course() const;
  void set_course(double value);

  // float speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.GPSSensor)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::TechnionFormulaAV::Messages::GPSConfig* config_;
  ::TechnionFormulaAV::Messages::Vector3D* position_;
  double latitude_;
  double longitude_;
  double course_;
  float speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class CameraSensor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.CameraSensor) */ {
 public:
  CameraSensor();
  virtual ~CameraSensor();

  CameraSensor(const CameraSensor& from);
  CameraSensor(CameraSensor&& from) noexcept
    : CameraSensor() {
    *this = ::std::move(from);
  }

  inline CameraSensor& operator=(const CameraSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraSensor& operator=(CameraSensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraSensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraSensor* internal_default_instance() {
    return reinterpret_cast<const CameraSensor*>(
               &_CameraSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CameraSensor* other);
  friend void swap(CameraSensor& a, CameraSensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraSensor* New() const final {
    return CreateMaybeMessage<CameraSensor>(nullptr);
  }

  CameraSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraSensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraSensor& from);
  void MergeFrom(const CameraSensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraSensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.CameraSensor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pixels = 3;
  void clear_pixels();
  static const int kPixelsFieldNumber = 3;
  const std::string& pixels() const;
  void set_pixels(const std::string& value);
  void set_pixels(std::string&& value);
  void set_pixels(const char* value);
  void set_pixels(const void* value, size_t size);
  std::string* mutable_pixels();
  std::string* release_pixels();
  void set_allocated_pixels(std::string* pixels);

  // .TechnionFormulaAV.Messages.CameraConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::TechnionFormulaAV::Messages::CameraConfig& config() const;
  ::TechnionFormulaAV::Messages::CameraConfig* release_config();
  ::TechnionFormulaAV::Messages::CameraConfig* mutable_config();
  void set_allocated_config(::TechnionFormulaAV::Messages::CameraConfig* config);

  // uint32 frame_number = 2;
  void clear_frame_number();
  static const int kFrameNumberFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 frame_number() const;
  void set_frame_number(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.CameraSensor)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pixels_;
  ::TechnionFormulaAV::Messages::CameraConfig* config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frame_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class DepthCameraSensor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.DepthCameraSensor) */ {
 public:
  DepthCameraSensor();
  virtual ~DepthCameraSensor();

  DepthCameraSensor(const DepthCameraSensor& from);
  DepthCameraSensor(DepthCameraSensor&& from) noexcept
    : DepthCameraSensor() {
    *this = ::std::move(from);
  }

  inline DepthCameraSensor& operator=(const DepthCameraSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepthCameraSensor& operator=(DepthCameraSensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DepthCameraSensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthCameraSensor* internal_default_instance() {
    return reinterpret_cast<const DepthCameraSensor*>(
               &_DepthCameraSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DepthCameraSensor* other);
  friend void swap(DepthCameraSensor& a, DepthCameraSensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthCameraSensor* New() const final {
    return CreateMaybeMessage<DepthCameraSensor>(nullptr);
  }

  DepthCameraSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DepthCameraSensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DepthCameraSensor& from);
  void MergeFrom(const DepthCameraSensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthCameraSensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.DepthCameraSensor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pixels = 5;
  void clear_pixels();
  static const int kPixelsFieldNumber = 5;
  const std::string& pixels() const;
  void set_pixels(const std::string& value);
  void set_pixels(std::string&& value);
  void set_pixels(const char* value);
  void set_pixels(const void* value, size_t size);
  std::string* mutable_pixels();
  std::string* release_pixels();
  void set_allocated_pixels(std::string* pixels);

  // .TechnionFormulaAV.Messages.DepthCameraConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::TechnionFormulaAV::Messages::DepthCameraConfig& config() const;
  ::TechnionFormulaAV::Messages::DepthCameraConfig* release_config();
  ::TechnionFormulaAV::Messages::DepthCameraConfig* mutable_config();
  void set_allocated_config(::TechnionFormulaAV::Messages::DepthCameraConfig* config);

  // uint32 frame_number = 2;
  void clear_frame_number();
  static const int kFrameNumberFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 frame_number() const;
  void set_frame_number(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.DepthCameraSensor)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pixels_;
  ::TechnionFormulaAV::Messages::DepthCameraConfig* config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frame_number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class LidarSensor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.LidarSensor) */ {
 public:
  LidarSensor();
  virtual ~LidarSensor();

  LidarSensor(const LidarSensor& from);
  LidarSensor(LidarSensor&& from) noexcept
    : LidarSensor() {
    *this = ::std::move(from);
  }

  inline LidarSensor& operator=(const LidarSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarSensor& operator=(LidarSensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LidarSensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarSensor* internal_default_instance() {
    return reinterpret_cast<const LidarSensor*>(
               &_LidarSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(LidarSensor* other);
  friend void swap(LidarSensor& a, LidarSensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarSensor* New() const final {
    return CreateMaybeMessage<LidarSensor>(nullptr);
  }

  LidarSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LidarSensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LidarSensor& from);
  void MergeFrom(const LidarSensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarSensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.LidarSensor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TechnionFormulaAV.Messages.Vector3D points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  ::TechnionFormulaAV::Messages::Vector3D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TechnionFormulaAV::Messages::Vector3D >*
      mutable_points();
  const ::TechnionFormulaAV::Messages::Vector3D& points(int index) const;
  ::TechnionFormulaAV::Messages::Vector3D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TechnionFormulaAV::Messages::Vector3D >&
      points() const;

  // .TechnionFormulaAV.Messages.LidarConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::TechnionFormulaAV::Messages::LidarConfig& config() const;
  ::TechnionFormulaAV::Messages::LidarConfig* release_config();
  ::TechnionFormulaAV::Messages::LidarConfig* mutable_config();
  void set_allocated_config(::TechnionFormulaAV::Messages::LidarConfig* config);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.LidarSensor)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TechnionFormulaAV::Messages::Vector3D > points_;
  ::TechnionFormulaAV::Messages::LidarConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class ActualDriveInstructions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.ActualDriveInstructions) */ {
 public:
  ActualDriveInstructions();
  virtual ~ActualDriveInstructions();

  ActualDriveInstructions(const ActualDriveInstructions& from);
  ActualDriveInstructions(ActualDriveInstructions&& from) noexcept
    : ActualDriveInstructions() {
    *this = ::std::move(from);
  }

  inline ActualDriveInstructions& operator=(const ActualDriveInstructions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActualDriveInstructions& operator=(ActualDriveInstructions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActualDriveInstructions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActualDriveInstructions* internal_default_instance() {
    return reinterpret_cast<const ActualDriveInstructions*>(
               &_ActualDriveInstructions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ActualDriveInstructions* other);
  friend void swap(ActualDriveInstructions& a, ActualDriveInstructions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActualDriveInstructions* New() const final {
    return CreateMaybeMessage<ActualDriveInstructions>(nullptr);
  }

  ActualDriveInstructions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActualDriveInstructions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActualDriveInstructions& from);
  void MergeFrom(const ActualDriveInstructions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActualDriveInstructions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.ActualDriveInstructions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float actual_gas = 1;
  void clear_actual_gas();
  static const int kActualGasFieldNumber = 1;
  float actual_gas() const;
  void set_actual_gas(float value);

  // float actual_brakes = 2;
  void clear_actual_brakes();
  static const int kActualBrakesFieldNumber = 2;
  float actual_brakes() const;
  void set_actual_brakes(float value);

  // float actual_steering = 3;
  void clear_actual_steering();
  static const int kActualSteeringFieldNumber = 3;
  float actual_steering() const;
  void set_actual_steering(float value);

  // float optimal_speed = 4;
  void clear_optimal_speed();
  static const int kOptimalSpeedFieldNumber = 4;
  float optimal_speed() const;
  void set_optimal_speed(float value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.ActualDriveInstructions)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float actual_gas_;
  float actual_brakes_;
  float actual_steering_;
  float optimal_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Can :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TechnionFormulaAV.Messages.Can) */ {
 public:
  Can();
  virtual ~Can();

  Can(const Can& from);
  Can(Can&& from) noexcept
    : Can() {
    *this = ::std::move(from);
  }

  inline Can& operator=(const Can& from) {
    CopyFrom(from);
    return *this;
  }
  inline Can& operator=(Can&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Can& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Can* internal_default_instance() {
    return reinterpret_cast<const Can*>(
               &_Can_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Can* other);
  friend void swap(Can& a, Can& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Can* New() const final {
    return CreateMaybeMessage<Can>(nullptr);
  }

  Can* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Can>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Can& from);
  void MergeFrom(const Can& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Can* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TechnionFormulaAV.Messages.Can";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 data = 5;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 data(int index) const;
  void set_data(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_data(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_data();

  // uint32 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 id_type = 3;
  void clear_id_type();
  static const int kIdTypeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_type() const;
  void set_id_type(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 data_length = 4;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 data_length() const;
  void set_data_length(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TechnionFormulaAV.Messages.Can)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 data_length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IMUConfig

// uint32 sensor_id = 1;
inline void IMUConfig::clear_sensor_id() {
  sensor_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMUConfig::sensor_id() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUConfig.sensor_id)
  return sensor_id_;
}
inline void IMUConfig::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensor_id_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.IMUConfig.sensor_id)
}

// .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
inline bool IMUConfig::has_sensor_position() const {
  return this != internal_default_instance() && sensor_position_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& IMUConfig::sensor_position() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = sensor_position_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUConfig.sensor_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUConfig::release_sensor_position() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUConfig.sensor_position)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = sensor_position_;
  sensor_position_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUConfig::mutable_sensor_position() {
  
  if (sensor_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    sensor_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUConfig.sensor_position)
  return sensor_position_;
}
inline void IMUConfig::set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_position_);
  }
  if (sensor_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_position, submessage_arena);
    }
    
  } else {
    
  }
  sensor_position_ = sensor_position;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUConfig.sensor_position)
}

// -------------------------------------------------------------------

// GPSConfig

// uint32 sensor_id = 1;
inline void GPSConfig::clear_sensor_id() {
  sensor_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GPSConfig::sensor_id() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSConfig.sensor_id)
  return sensor_id_;
}
inline void GPSConfig::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensor_id_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.GPSConfig.sensor_id)
}

// .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
inline bool GPSConfig::has_sensor_position() const {
  return this != internal_default_instance() && sensor_position_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& GPSConfig::sensor_position() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = sensor_position_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSConfig.sensor_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* GPSConfig::release_sensor_position() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.GPSConfig.sensor_position)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = sensor_position_;
  sensor_position_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* GPSConfig::mutable_sensor_position() {
  
  if (sensor_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    sensor_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.GPSConfig.sensor_position)
  return sensor_position_;
}
inline void GPSConfig::set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_position_);
  }
  if (sensor_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_position, submessage_arena);
    }
    
  } else {
    
  }
  sensor_position_ = sensor_position;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.GPSConfig.sensor_position)
}

// -------------------------------------------------------------------

// CameraConfig

// uint32 sensor_id = 1;
inline void CameraConfig::clear_sensor_id() {
  sensor_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraConfig::sensor_id() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraConfig.sensor_id)
  return sensor_id_;
}
inline void CameraConfig::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensor_id_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CameraConfig.sensor_id)
}

// .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
inline bool CameraConfig::has_sensor_position() const {
  return this != internal_default_instance() && sensor_position_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& CameraConfig::sensor_position() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = sensor_position_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraConfig.sensor_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* CameraConfig::release_sensor_position() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.CameraConfig.sensor_position)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = sensor_position_;
  sensor_position_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* CameraConfig::mutable_sensor_position() {
  
  if (sensor_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    sensor_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.CameraConfig.sensor_position)
  return sensor_position_;
}
inline void CameraConfig::set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_position_);
  }
  if (sensor_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_position, submessage_arena);
    }
    
  } else {
    
  }
  sensor_position_ = sensor_position;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.CameraConfig.sensor_position)
}

// float hfov = 3;
inline void CameraConfig::clear_hfov() {
  hfov_ = 0;
}
inline float CameraConfig::hfov() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraConfig.hfov)
  return hfov_;
}
inline void CameraConfig::set_hfov(float value) {
  
  hfov_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CameraConfig.hfov)
}

// float vfov = 4;
inline void CameraConfig::clear_vfov() {
  vfov_ = 0;
}
inline float CameraConfig::vfov() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraConfig.vfov)
  return vfov_;
}
inline void CameraConfig::set_vfov(float value) {
  
  vfov_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CameraConfig.vfov)
}

// uint32 width = 5;
inline void CameraConfig::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraConfig::width() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraConfig.width)
  return width_;
}
inline void CameraConfig::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CameraConfig.width)
}

// uint32 height = 6;
inline void CameraConfig::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraConfig::height() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraConfig.height)
  return height_;
}
inline void CameraConfig::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CameraConfig.height)
}

// -------------------------------------------------------------------

// LidarConfig

// uint32 sensor_id = 1;
inline void LidarConfig::clear_sensor_id() {
  sensor_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LidarConfig::sensor_id() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.LidarConfig.sensor_id)
  return sensor_id_;
}
inline void LidarConfig::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensor_id_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.LidarConfig.sensor_id)
}

// .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
inline bool LidarConfig::has_sensor_position() const {
  return this != internal_default_instance() && sensor_position_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& LidarConfig::sensor_position() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = sensor_position_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.LidarConfig.sensor_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* LidarConfig::release_sensor_position() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.LidarConfig.sensor_position)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = sensor_position_;
  sensor_position_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* LidarConfig::mutable_sensor_position() {
  
  if (sensor_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    sensor_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.LidarConfig.sensor_position)
  return sensor_position_;
}
inline void LidarConfig::set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_position_);
  }
  if (sensor_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_position, submessage_arena);
    }
    
  } else {
    
  }
  sensor_position_ = sensor_position;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.LidarConfig.sensor_position)
}

// float hfov = 3;
inline void LidarConfig::clear_hfov() {
  hfov_ = 0;
}
inline float LidarConfig::hfov() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.LidarConfig.hfov)
  return hfov_;
}
inline void LidarConfig::set_hfov(float value) {
  
  hfov_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.LidarConfig.hfov)
}

// float vfov = 4;
inline void LidarConfig::clear_vfov() {
  vfov_ = 0;
}
inline float LidarConfig::vfov() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.LidarConfig.vfov)
  return vfov_;
}
inline void LidarConfig::set_vfov(float value) {
  
  vfov_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.LidarConfig.vfov)
}

// -------------------------------------------------------------------

// DepthCameraConfig

// uint32 sensor_id = 1;
inline void DepthCameraConfig::clear_sensor_id() {
  sensor_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepthCameraConfig::sensor_id() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraConfig.sensor_id)
  return sensor_id_;
}
inline void DepthCameraConfig::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensor_id_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraConfig.sensor_id)
}

// .TechnionFormulaAV.Messages.Vector3D sensor_position = 2;
inline bool DepthCameraConfig::has_sensor_position() const {
  return this != internal_default_instance() && sensor_position_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& DepthCameraConfig::sensor_position() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = sensor_position_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraConfig.sensor_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* DepthCameraConfig::release_sensor_position() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.DepthCameraConfig.sensor_position)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = sensor_position_;
  sensor_position_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* DepthCameraConfig::mutable_sensor_position() {
  
  if (sensor_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    sensor_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.DepthCameraConfig.sensor_position)
  return sensor_position_;
}
inline void DepthCameraConfig::set_allocated_sensor_position(::TechnionFormulaAV::Messages::Vector3D* sensor_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_position_);
  }
  if (sensor_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_position, submessage_arena);
    }
    
  } else {
    
  }
  sensor_position_ = sensor_position;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.DepthCameraConfig.sensor_position)
}

// float hfov = 3;
inline void DepthCameraConfig::clear_hfov() {
  hfov_ = 0;
}
inline float DepthCameraConfig::hfov() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraConfig.hfov)
  return hfov_;
}
inline void DepthCameraConfig::set_hfov(float value) {
  
  hfov_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraConfig.hfov)
}

// float vfov = 4;
inline void DepthCameraConfig::clear_vfov() {
  vfov_ = 0;
}
inline float DepthCameraConfig::vfov() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraConfig.vfov)
  return vfov_;
}
inline void DepthCameraConfig::set_vfov(float value) {
  
  vfov_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraConfig.vfov)
}

// uint32 width = 5;
inline void DepthCameraConfig::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepthCameraConfig::width() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraConfig.width)
  return width_;
}
inline void DepthCameraConfig::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraConfig.width)
}

// uint32 height = 6;
inline void DepthCameraConfig::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepthCameraConfig::height() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraConfig.height)
  return height_;
}
inline void DepthCameraConfig::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraConfig.height)
}

// .TechnionFormulaAV.Messages.DepthCameraDataType data_type = 7;
inline void DepthCameraConfig::clear_data_type() {
  data_type_ = 0;
}
inline ::TechnionFormulaAV::Messages::DepthCameraDataType DepthCameraConfig::data_type() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraConfig.data_type)
  return static_cast< ::TechnionFormulaAV::Messages::DepthCameraDataType >(data_type_);
}
inline void DepthCameraConfig::set_data_type(::TechnionFormulaAV::Messages::DepthCameraDataType value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraConfig.data_type)
}

// -------------------------------------------------------------------

// CarMeasurments

// double wheel_velocity_rear_left = 1;
inline void CarMeasurments::clear_wheel_velocity_rear_left() {
  wheel_velocity_rear_left_ = 0;
}
inline double CarMeasurments::wheel_velocity_rear_left() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_rear_left)
  return wheel_velocity_rear_left_;
}
inline void CarMeasurments::set_wheel_velocity_rear_left(double value) {
  
  wheel_velocity_rear_left_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_rear_left)
}

// double wheel_velocity_rear_right = 2;
inline void CarMeasurments::clear_wheel_velocity_rear_right() {
  wheel_velocity_rear_right_ = 0;
}
inline double CarMeasurments::wheel_velocity_rear_right() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_rear_right)
  return wheel_velocity_rear_right_;
}
inline void CarMeasurments::set_wheel_velocity_rear_right(double value) {
  
  wheel_velocity_rear_right_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_rear_right)
}

// double wheel_velocity_front_left = 3;
inline void CarMeasurments::clear_wheel_velocity_front_left() {
  wheel_velocity_front_left_ = 0;
}
inline double CarMeasurments::wheel_velocity_front_left() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_front_left)
  return wheel_velocity_front_left_;
}
inline void CarMeasurments::set_wheel_velocity_front_left(double value) {
  
  wheel_velocity_front_left_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_front_left)
}

// double wheel_velocity_front_right = 4;
inline void CarMeasurments::clear_wheel_velocity_front_right() {
  wheel_velocity_front_right_ = 0;
}
inline double CarMeasurments::wheel_velocity_front_right() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_front_right)
  return wheel_velocity_front_right_;
}
inline void CarMeasurments::set_wheel_velocity_front_right(double value) {
  
  wheel_velocity_front_right_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CarMeasurments.wheel_velocity_front_right)
}

// double throttle_position = 5;
inline void CarMeasurments::clear_throttle_position() {
  throttle_position_ = 0;
}
inline double CarMeasurments::throttle_position() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarMeasurments.throttle_position)
  return throttle_position_;
}
inline void CarMeasurments::set_throttle_position(double value) {
  
  throttle_position_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CarMeasurments.throttle_position)
}

// double steering_angle = 6;
inline void CarMeasurments::clear_steering_angle() {
  steering_angle_ = 0;
}
inline double CarMeasurments::steering_angle() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarMeasurments.steering_angle)
  return steering_angle_;
}
inline void CarMeasurments::set_steering_angle(double value) {
  
  steering_angle_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CarMeasurments.steering_angle)
}

// double brakes_position = 7;
inline void CarMeasurments::clear_brakes_position() {
  brakes_position_ = 0;
}
inline double CarMeasurments::brakes_position() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarMeasurments.brakes_position)
  return brakes_position_;
}
inline void CarMeasurments::set_brakes_position(double value) {
  
  brakes_position_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CarMeasurments.brakes_position)
}

// -------------------------------------------------------------------

// IMUMeasurments

// .TechnionFormulaAV.Messages.Vector3D acceleration = 2;
inline bool IMUMeasurments::has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& IMUMeasurments::acceleration() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = acceleration_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUMeasurments.acceleration)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::release_acceleration() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUMeasurments.acceleration)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::mutable_acceleration() {
  
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUMeasurments.acceleration)
  return acceleration_;
}
inline void IMUMeasurments::set_allocated_acceleration(::TechnionFormulaAV::Messages::Vector3D* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUMeasurments.acceleration)
}

// .TechnionFormulaAV.Messages.Vector3D angular_acceleration = 3;
inline bool IMUMeasurments::has_angular_acceleration() const {
  return this != internal_default_instance() && angular_acceleration_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& IMUMeasurments::angular_acceleration() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = angular_acceleration_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUMeasurments.angular_acceleration)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::release_angular_acceleration() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUMeasurments.angular_acceleration)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = angular_acceleration_;
  angular_acceleration_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::mutable_angular_acceleration() {
  
  if (angular_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    angular_acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUMeasurments.angular_acceleration)
  return angular_acceleration_;
}
inline void IMUMeasurments::set_allocated_angular_acceleration(::TechnionFormulaAV::Messages::Vector3D* angular_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_acceleration_);
  }
  if (angular_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      angular_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  angular_acceleration_ = angular_acceleration;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUMeasurments.angular_acceleration)
}

// .TechnionFormulaAV.Messages.Vector3D velocity = 4;
inline bool IMUMeasurments::has_velocity() const {
  return this != internal_default_instance() && velocity_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& IMUMeasurments::velocity() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = velocity_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUMeasurments.velocity)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::release_velocity() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUMeasurments.velocity)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::mutable_velocity() {
  
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUMeasurments.velocity)
  return velocity_;
}
inline void IMUMeasurments::set_allocated_velocity(::TechnionFormulaAV::Messages::Vector3D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUMeasurments.velocity)
}

// .TechnionFormulaAV.Messages.Vector3D angular_velocity = 5;
inline bool IMUMeasurments::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& IMUMeasurments::angular_velocity() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUMeasurments.angular_velocity)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUMeasurments.angular_velocity)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = angular_velocity_;
  angular_velocity_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::mutable_angular_velocity() {
  
  if (angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    angular_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUMeasurments.angular_velocity)
  return angular_velocity_;
}
inline void IMUMeasurments::set_allocated_angular_velocity(::TechnionFormulaAV::Messages::Vector3D* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_velocity_);
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUMeasurments.angular_velocity)
}

// .TechnionFormulaAV.Messages.Vector3D orientation = 6;
inline bool IMUMeasurments::has_orientation() const {
  return this != internal_default_instance() && orientation_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& IMUMeasurments::orientation() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = orientation_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUMeasurments.orientation)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::release_orientation() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUMeasurments.orientation)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* IMUMeasurments::mutable_orientation() {
  
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUMeasurments.orientation)
  return orientation_;
}
inline void IMUMeasurments::set_allocated_orientation(::TechnionFormulaAV::Messages::Vector3D* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUMeasurments.orientation)
}

// double heading = 7;
inline void IMUMeasurments::clear_heading() {
  heading_ = 0;
}
inline double IMUMeasurments::heading() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUMeasurments.heading)
  return heading_;
}
inline void IMUMeasurments::set_heading(double value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.IMUMeasurments.heading)
}

// -------------------------------------------------------------------

// IMUSensor

// .TechnionFormulaAV.Messages.IMUConfig config = 1;
inline bool IMUSensor::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void IMUSensor::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::IMUConfig& IMUSensor::config() const {
  const ::TechnionFormulaAV::Messages::IMUConfig* p = config_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUSensor.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::IMUConfig*>(
      &::TechnionFormulaAV::Messages::_IMUConfig_default_instance_);
}
inline ::TechnionFormulaAV::Messages::IMUConfig* IMUSensor::release_config() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUSensor.config)
  
  ::TechnionFormulaAV::Messages::IMUConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::IMUConfig* IMUSensor::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::IMUConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUSensor.config)
  return config_;
}
inline void IMUSensor::set_allocated_config(::TechnionFormulaAV::Messages::IMUConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUSensor.config)
}

// .TechnionFormulaAV.Messages.IMUMeasurments imu_measurments = 2;
inline bool IMUSensor::has_imu_measurments() const {
  return this != internal_default_instance() && imu_measurments_ != nullptr;
}
inline void IMUSensor::clear_imu_measurments() {
  if (GetArenaNoVirtual() == nullptr && imu_measurments_ != nullptr) {
    delete imu_measurments_;
  }
  imu_measurments_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::IMUMeasurments& IMUSensor::imu_measurments() const {
  const ::TechnionFormulaAV::Messages::IMUMeasurments* p = imu_measurments_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.IMUSensor.imu_measurments)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::IMUMeasurments*>(
      &::TechnionFormulaAV::Messages::_IMUMeasurments_default_instance_);
}
inline ::TechnionFormulaAV::Messages::IMUMeasurments* IMUSensor::release_imu_measurments() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.IMUSensor.imu_measurments)
  
  ::TechnionFormulaAV::Messages::IMUMeasurments* temp = imu_measurments_;
  imu_measurments_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::IMUMeasurments* IMUSensor::mutable_imu_measurments() {
  
  if (imu_measurments_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::IMUMeasurments>(GetArenaNoVirtual());
    imu_measurments_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.IMUSensor.imu_measurments)
  return imu_measurments_;
}
inline void IMUSensor::set_allocated_imu_measurments(::TechnionFormulaAV::Messages::IMUMeasurments* imu_measurments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete imu_measurments_;
  }
  if (imu_measurments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      imu_measurments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imu_measurments, submessage_arena);
    }
    
  } else {
    
  }
  imu_measurments_ = imu_measurments;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.IMUSensor.imu_measurments)
}

// -------------------------------------------------------------------

// CarData

// .TechnionFormulaAV.Messages.IMUSensor imu_sensor = 1;
inline bool CarData::has_imu_sensor() const {
  return this != internal_default_instance() && imu_sensor_ != nullptr;
}
inline void CarData::clear_imu_sensor() {
  if (GetArenaNoVirtual() == nullptr && imu_sensor_ != nullptr) {
    delete imu_sensor_;
  }
  imu_sensor_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::IMUSensor& CarData::imu_sensor() const {
  const ::TechnionFormulaAV::Messages::IMUSensor* p = imu_sensor_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarData.imu_sensor)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::IMUSensor*>(
      &::TechnionFormulaAV::Messages::_IMUSensor_default_instance_);
}
inline ::TechnionFormulaAV::Messages::IMUSensor* CarData::release_imu_sensor() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.CarData.imu_sensor)
  
  ::TechnionFormulaAV::Messages::IMUSensor* temp = imu_sensor_;
  imu_sensor_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::IMUSensor* CarData::mutable_imu_sensor() {
  
  if (imu_sensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::IMUSensor>(GetArenaNoVirtual());
    imu_sensor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.CarData.imu_sensor)
  return imu_sensor_;
}
inline void CarData::set_allocated_imu_sensor(::TechnionFormulaAV::Messages::IMUSensor* imu_sensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete imu_sensor_;
  }
  if (imu_sensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      imu_sensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imu_sensor, submessage_arena);
    }
    
  } else {
    
  }
  imu_sensor_ = imu_sensor;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.CarData.imu_sensor)
}

// .TechnionFormulaAV.Messages.CarMeasurments car_measurments = 2;
inline bool CarData::has_car_measurments() const {
  return this != internal_default_instance() && car_measurments_ != nullptr;
}
inline void CarData::clear_car_measurments() {
  if (GetArenaNoVirtual() == nullptr && car_measurments_ != nullptr) {
    delete car_measurments_;
  }
  car_measurments_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::CarMeasurments& CarData::car_measurments() const {
  const ::TechnionFormulaAV::Messages::CarMeasurments* p = car_measurments_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CarData.car_measurments)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::CarMeasurments*>(
      &::TechnionFormulaAV::Messages::_CarMeasurments_default_instance_);
}
inline ::TechnionFormulaAV::Messages::CarMeasurments* CarData::release_car_measurments() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.CarData.car_measurments)
  
  ::TechnionFormulaAV::Messages::CarMeasurments* temp = car_measurments_;
  car_measurments_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::CarMeasurments* CarData::mutable_car_measurments() {
  
  if (car_measurments_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::CarMeasurments>(GetArenaNoVirtual());
    car_measurments_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.CarData.car_measurments)
  return car_measurments_;
}
inline void CarData::set_allocated_car_measurments(::TechnionFormulaAV::Messages::CarMeasurments* car_measurments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete car_measurments_;
  }
  if (car_measurments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      car_measurments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, car_measurments, submessage_arena);
    }
    
  } else {
    
  }
  car_measurments_ = car_measurments;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.CarData.car_measurments)
}

// -------------------------------------------------------------------

// GPSSensor

// .TechnionFormulaAV.Messages.GPSConfig config = 1;
inline bool GPSSensor::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void GPSSensor::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::GPSConfig& GPSSensor::config() const {
  const ::TechnionFormulaAV::Messages::GPSConfig* p = config_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSSensor.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::GPSConfig*>(
      &::TechnionFormulaAV::Messages::_GPSConfig_default_instance_);
}
inline ::TechnionFormulaAV::Messages::GPSConfig* GPSSensor::release_config() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.GPSSensor.config)
  
  ::TechnionFormulaAV::Messages::GPSConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::GPSConfig* GPSSensor::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::GPSConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.GPSSensor.config)
  return config_;
}
inline void GPSSensor::set_allocated_config(::TechnionFormulaAV::Messages::GPSConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.GPSSensor.config)
}

// .TechnionFormulaAV.Messages.Vector3D position = 2;
inline bool GPSSensor::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& GPSSensor::position() const {
  const ::TechnionFormulaAV::Messages::Vector3D* p = position_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSSensor.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::Vector3D*>(
      &::TechnionFormulaAV::Messages::_Vector3D_default_instance_);
}
inline ::TechnionFormulaAV::Messages::Vector3D* GPSSensor::release_position() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.GPSSensor.position)
  
  ::TechnionFormulaAV::Messages::Vector3D* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::Vector3D* GPSSensor::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::Vector3D>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.GPSSensor.position)
  return position_;
}
inline void GPSSensor::set_allocated_position(::TechnionFormulaAV::Messages::Vector3D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.GPSSensor.position)
}

// float speed = 3;
inline void GPSSensor::clear_speed() {
  speed_ = 0;
}
inline float GPSSensor::speed() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSSensor.speed)
  return speed_;
}
inline void GPSSensor::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.GPSSensor.speed)
}

// double latitude = 4;
inline void GPSSensor::clear_latitude() {
  latitude_ = 0;
}
inline double GPSSensor::latitude() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSSensor.latitude)
  return latitude_;
}
inline void GPSSensor::set_latitude(double value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.GPSSensor.latitude)
}

// double longitude = 5;
inline void GPSSensor::clear_longitude() {
  longitude_ = 0;
}
inline double GPSSensor::longitude() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSSensor.longitude)
  return longitude_;
}
inline void GPSSensor::set_longitude(double value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.GPSSensor.longitude)
}

// double course = 6;
inline void GPSSensor::clear_course() {
  course_ = 0;
}
inline double GPSSensor::course() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.GPSSensor.course)
  return course_;
}
inline void GPSSensor::set_course(double value) {
  
  course_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.GPSSensor.course)
}

// -------------------------------------------------------------------

// CameraSensor

// .TechnionFormulaAV.Messages.CameraConfig config = 1;
inline bool CameraSensor::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void CameraSensor::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::CameraConfig& CameraSensor::config() const {
  const ::TechnionFormulaAV::Messages::CameraConfig* p = config_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraSensor.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::CameraConfig*>(
      &::TechnionFormulaAV::Messages::_CameraConfig_default_instance_);
}
inline ::TechnionFormulaAV::Messages::CameraConfig* CameraSensor::release_config() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.CameraSensor.config)
  
  ::TechnionFormulaAV::Messages::CameraConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::CameraConfig* CameraSensor::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::CameraConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.CameraSensor.config)
  return config_;
}
inline void CameraSensor::set_allocated_config(::TechnionFormulaAV::Messages::CameraConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.CameraSensor.config)
}

// uint32 frame_number = 2;
inline void CameraSensor::clear_frame_number() {
  frame_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraSensor::frame_number() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraSensor.frame_number)
  return frame_number_;
}
inline void CameraSensor::set_frame_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frame_number_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CameraSensor.frame_number)
}

// bytes pixels = 3;
inline void CameraSensor::clear_pixels() {
  pixels_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CameraSensor::pixels() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.CameraSensor.pixels)
  return pixels_.GetNoArena();
}
inline void CameraSensor::set_pixels(const std::string& value) {
  
  pixels_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.CameraSensor.pixels)
}
inline void CameraSensor::set_pixels(std::string&& value) {
  
  pixels_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TechnionFormulaAV.Messages.CameraSensor.pixels)
}
inline void CameraSensor::set_pixels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pixels_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TechnionFormulaAV.Messages.CameraSensor.pixels)
}
inline void CameraSensor::set_pixels(const void* value, size_t size) {
  
  pixels_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TechnionFormulaAV.Messages.CameraSensor.pixels)
}
inline std::string* CameraSensor::mutable_pixels() {
  
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.CameraSensor.pixels)
  return pixels_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CameraSensor::release_pixels() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.CameraSensor.pixels)
  
  return pixels_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CameraSensor::set_allocated_pixels(std::string* pixels) {
  if (pixels != nullptr) {
    
  } else {
    
  }
  pixels_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pixels);
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.CameraSensor.pixels)
}

// -------------------------------------------------------------------

// DepthCameraSensor

// .TechnionFormulaAV.Messages.DepthCameraConfig config = 1;
inline bool DepthCameraSensor::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void DepthCameraSensor::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::DepthCameraConfig& DepthCameraSensor::config() const {
  const ::TechnionFormulaAV::Messages::DepthCameraConfig* p = config_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraSensor.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::DepthCameraConfig*>(
      &::TechnionFormulaAV::Messages::_DepthCameraConfig_default_instance_);
}
inline ::TechnionFormulaAV::Messages::DepthCameraConfig* DepthCameraSensor::release_config() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.DepthCameraSensor.config)
  
  ::TechnionFormulaAV::Messages::DepthCameraConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::DepthCameraConfig* DepthCameraSensor::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::DepthCameraConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.DepthCameraSensor.config)
  return config_;
}
inline void DepthCameraSensor::set_allocated_config(::TechnionFormulaAV::Messages::DepthCameraConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.DepthCameraSensor.config)
}

// uint32 frame_number = 2;
inline void DepthCameraSensor::clear_frame_number() {
  frame_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepthCameraSensor::frame_number() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraSensor.frame_number)
  return frame_number_;
}
inline void DepthCameraSensor::set_frame_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frame_number_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraSensor.frame_number)
}

// uint32 width = 3;
inline void DepthCameraSensor::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepthCameraSensor::width() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraSensor.width)
  return width_;
}
inline void DepthCameraSensor::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraSensor.width)
}

// uint32 height = 4;
inline void DepthCameraSensor::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepthCameraSensor::height() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraSensor.height)
  return height_;
}
inline void DepthCameraSensor::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraSensor.height)
}

// bytes pixels = 5;
inline void DepthCameraSensor::clear_pixels() {
  pixels_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DepthCameraSensor::pixels() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
  return pixels_.GetNoArena();
}
inline void DepthCameraSensor::set_pixels(const std::string& value) {
  
  pixels_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
}
inline void DepthCameraSensor::set_pixels(std::string&& value) {
  
  pixels_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
}
inline void DepthCameraSensor::set_pixels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pixels_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
}
inline void DepthCameraSensor::set_pixels(const void* value, size_t size) {
  
  pixels_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
}
inline std::string* DepthCameraSensor::mutable_pixels() {
  
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
  return pixels_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DepthCameraSensor::release_pixels() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
  
  return pixels_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DepthCameraSensor::set_allocated_pixels(std::string* pixels) {
  if (pixels != nullptr) {
    
  } else {
    
  }
  pixels_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pixels);
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.DepthCameraSensor.pixels)
}

// -------------------------------------------------------------------

// LidarSensor

// .TechnionFormulaAV.Messages.LidarConfig config = 1;
inline bool LidarSensor::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void LidarSensor::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::TechnionFormulaAV::Messages::LidarConfig& LidarSensor::config() const {
  const ::TechnionFormulaAV::Messages::LidarConfig* p = config_;
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.LidarSensor.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::TechnionFormulaAV::Messages::LidarConfig*>(
      &::TechnionFormulaAV::Messages::_LidarConfig_default_instance_);
}
inline ::TechnionFormulaAV::Messages::LidarConfig* LidarSensor::release_config() {
  // @@protoc_insertion_point(field_release:TechnionFormulaAV.Messages.LidarSensor.config)
  
  ::TechnionFormulaAV::Messages::LidarConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::TechnionFormulaAV::Messages::LidarConfig* LidarSensor::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::TechnionFormulaAV::Messages::LidarConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.LidarSensor.config)
  return config_;
}
inline void LidarSensor::set_allocated_config(::TechnionFormulaAV::Messages::LidarConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:TechnionFormulaAV.Messages.LidarSensor.config)
}

// repeated .TechnionFormulaAV.Messages.Vector3D points = 2;
inline int LidarSensor::points_size() const {
  return points_.size();
}
inline ::TechnionFormulaAV::Messages::Vector3D* LidarSensor::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:TechnionFormulaAV.Messages.LidarSensor.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TechnionFormulaAV::Messages::Vector3D >*
LidarSensor::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:TechnionFormulaAV.Messages.LidarSensor.points)
  return &points_;
}
inline const ::TechnionFormulaAV::Messages::Vector3D& LidarSensor::points(int index) const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.LidarSensor.points)
  return points_.Get(index);
}
inline ::TechnionFormulaAV::Messages::Vector3D* LidarSensor::add_points() {
  // @@protoc_insertion_point(field_add:TechnionFormulaAV.Messages.LidarSensor.points)
  return points_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TechnionFormulaAV::Messages::Vector3D >&
LidarSensor::points() const {
  // @@protoc_insertion_point(field_list:TechnionFormulaAV.Messages.LidarSensor.points)
  return points_;
}

// -------------------------------------------------------------------

// ActualDriveInstructions

// float actual_gas = 1;
inline void ActualDriveInstructions::clear_actual_gas() {
  actual_gas_ = 0;
}
inline float ActualDriveInstructions::actual_gas() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.ActualDriveInstructions.actual_gas)
  return actual_gas_;
}
inline void ActualDriveInstructions::set_actual_gas(float value) {
  
  actual_gas_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.ActualDriveInstructions.actual_gas)
}

// float actual_brakes = 2;
inline void ActualDriveInstructions::clear_actual_brakes() {
  actual_brakes_ = 0;
}
inline float ActualDriveInstructions::actual_brakes() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.ActualDriveInstructions.actual_brakes)
  return actual_brakes_;
}
inline void ActualDriveInstructions::set_actual_brakes(float value) {
  
  actual_brakes_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.ActualDriveInstructions.actual_brakes)
}

// float actual_steering = 3;
inline void ActualDriveInstructions::clear_actual_steering() {
  actual_steering_ = 0;
}
inline float ActualDriveInstructions::actual_steering() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.ActualDriveInstructions.actual_steering)
  return actual_steering_;
}
inline void ActualDriveInstructions::set_actual_steering(float value) {
  
  actual_steering_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.ActualDriveInstructions.actual_steering)
}

// float optimal_speed = 4;
inline void ActualDriveInstructions::clear_optimal_speed() {
  optimal_speed_ = 0;
}
inline float ActualDriveInstructions::optimal_speed() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.ActualDriveInstructions.optimal_speed)
  return optimal_speed_;
}
inline void ActualDriveInstructions::set_optimal_speed(float value) {
  
  optimal_speed_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.ActualDriveInstructions.optimal_speed)
}

// -------------------------------------------------------------------

// Can

// uint32 timestamp = 1;
inline void Can::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Can::timestamp() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.Can.timestamp)
  return timestamp_;
}
inline void Can::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.Can.timestamp)
}

// uint32 id = 2;
inline void Can::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Can::id() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.Can.id)
  return id_;
}
inline void Can::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.Can.id)
}

// uint32 id_type = 3;
inline void Can::clear_id_type() {
  id_type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Can::id_type() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.Can.id_type)
  return id_type_;
}
inline void Can::set_id_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_type_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.Can.id_type)
}

// uint32 data_length = 4;
inline void Can::clear_data_length() {
  data_length_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Can::data_length() const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.Can.data_length)
  return data_length_;
}
inline void Can::set_data_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  data_length_ = value;
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.Can.data_length)
}

// repeated uint32 data = 5;
inline int Can::data_size() const {
  return data_.size();
}
inline void Can::clear_data() {
  data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Can::data(int index) const {
  // @@protoc_insertion_point(field_get:TechnionFormulaAV.Messages.Can.data)
  return data_.Get(index);
}
inline void Can::set_data(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:TechnionFormulaAV.Messages.Can.data)
}
inline void Can::add_data(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:TechnionFormulaAV.Messages.Can.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Can::data() const {
  // @@protoc_insertion_point(field_list:TechnionFormulaAV.Messages.Can.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Can::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:TechnionFormulaAV.Messages.Can.data)
  return &data_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Messages
}  // namespace TechnionFormulaAV

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TechnionFormulaAV::Messages::DepthCameraDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TechnionFormulaAV::Messages::DepthCameraDataType>() {
  return ::TechnionFormulaAV::Messages::DepthCameraDataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
